#!/usr/bin/env node

/**
 * Generate Documentation Catalog
 * 
 * Automatically discovers all .md files in public/docs/ and generates
 * documentationCatalog.ts with parsed metadata (title, description, category).
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DOCS_DIR = path.join(__dirname, '../public/docs');
const OUTPUT_FILE = path.join(__dirname, '../src/config/documentationCatalog.ts');

// Category mapping based on filename patterns or folder structure
const CATEGORY_MAP = {
  'database': 'Architecture',
  'tenant': 'Architecture',
  'architecture': 'Architecture',
  'naming': 'Architecture',
  'app': 'Platform',
  'platform': 'Platform',
  'operation': 'Platform',
  'admin': 'Platform',
  'permission': 'Platform',
  'role': 'Platform',
  'test': 'Development',
  'development': 'Development',
  'implementation': 'Implementation',
  'sprint': 'Implementation',
  'summary': 'Implementation',
  'readme': 'Platform',
};

/**
 * Parse markdown content to extract metadata
 */
function parseMarkdown(content, filename) {
  const lines = content.split('\n');
  let title = filename.replace(/\.md$/, '').replace(/-/g, ' ');
  let description = '';
  let foundTitle = false;
  
  // Extract first # heading as title
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    
    if (line.startsWith('# ')) {
      title = line.replace(/^#\s+/, '');
      foundTitle = true;
      
      // Look for description in next non-empty lines
      for (let j = i + 1; j < Math.min(i + 10, lines.length); j++) {
        const descLine = lines[j].trim();
        if (descLine && !descLine.startsWith('#') && !descLine.startsWith('```')) {
          // Skip horizontal rules and empty lines
          if (descLine !== '---' && descLine.length > 10) {
            description = descLine.replace(/\*\*/g, '').replace(/\*/g, '').substring(0, 150);
            break;
          }
        }
      }
      break;
    }
  }
  
  return { title, description };
}

/**
 * Determine category based on filename
 */
function determineCategory(filename) {
  const lowerName = filename.toLowerCase();
  
  for (const [keyword, category] of Object.entries(CATEGORY_MAP)) {
    if (lowerName.includes(keyword)) {
      return category;
    }
  }
  
  return 'Platform'; // Default category
}

/**
 * Generate tags from filename
 */
function generateTags(filename) {
  const tags = filename
    .replace(/\.md$/, '')
    .split(/[-_]/)
    .filter(tag => tag.length > 2)
    .map(tag => tag.toLowerCase());
  
  return tags.slice(0, 4); // Max 4 tags
}

/**
 * Scan directory recursively for .md files
 */
function scanDirectory(dir, baseDir = dir) {
  const files = [];
  
  if (!fs.existsSync(dir)) {
    console.warn(`Directory not found: ${dir}`);
    return files;
  }
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    
    if (entry.isDirectory()) {
      files.push(...scanDirectory(fullPath, baseDir));
    } else if (entry.isFile() && entry.name.endsWith('.md')) {
      const relativePath = path.relative(baseDir, fullPath);
      files.push({
        filename: entry.name,
        fullPath,
        relativePath: `docs/${relativePath.replace(/\\/g, '/')}`,
      });
    }
  }
  
  return files;
}

/**
 * Main function
 */
function generateCatalog() {
  console.log('üîç Scanning for documentation files...');
  
  const files = scanDirectory(DOCS_DIR);
  
  if (files.length === 0) {
    console.warn('‚ö†Ô∏è  No markdown files found in public/docs/');
    return;
  }
  
  console.log(`üìÑ Found ${files.length} documentation files`);
  
  const catalog = files.map((file, index) => {
    const content = fs.readFileSync(file.fullPath, 'utf-8');
    const { title, description } = parseMarkdown(content, file.filename);
    const category = determineCategory(file.filename);
    const tags = generateTags(file.filename);
    
    // Generate ID from filename
    const id = file.filename
      .replace(/\.md$/, '')
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-');
    
    return {
      id,
      title,
      description: description || `Documentation for ${title}`,
      category,
      path: file.relativePath,
      tags,
    };
  });
  
  // Sort by category, then by title
  catalog.sort((a, b) => {
    if (a.category !== b.category) {
      return a.category.localeCompare(b.category);
    }
    return a.title.localeCompare(b.title);
  });
  
  // Generate TypeScript file
  const tsContent = `/**
 * Documentation Catalog
 * 
 * Auto-generated by scripts/generate-docs-catalog.js
 * DO NOT EDIT MANUALLY - Run 'npm run generate:docs' to regenerate
 * 
 * Last generated: ${new Date().toISOString()}
 */

export interface DocumentMetadata {
  id: string;
  title: string;
  description: string;
  category: 'Platform' | 'Architecture' | 'Development' | 'Implementation';
  path: string;
  tags?: string[];
}

export const documentationCatalog: DocumentMetadata[] = ${JSON.stringify(catalog, null, 2)};
`;
  
  fs.writeFileSync(OUTPUT_FILE, tsContent, 'utf-8');
  
  console.log('‚úÖ Documentation catalog generated successfully!');
  console.log(`üìù Output: ${OUTPUT_FILE}`);
  console.log(`üìä Total entries: ${catalog.length}`);
  
  // Print summary by category
  const categoryCount = catalog.reduce((acc, doc) => {
    acc[doc.category] = (acc[doc.category] || 0) + 1;
    return acc;
  }, {});
  
  console.log('\nüìã Summary by category:');
  Object.entries(categoryCount).forEach(([category, count]) => {
    console.log(`   ${category}: ${count}`);
  });
}

// Run
try {
  generateCatalog();
} catch (error) {
  console.error('‚ùå Error generating catalog:', error);
  process.exit(1);
}
